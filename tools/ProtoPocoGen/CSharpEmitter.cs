using System.Text;

namespace ProtoPocoGen;

public class CSharpEmitter
{
    private readonly Dictionary<string, ProtoFile> _files;
    private readonly Dictionary<string, string> _typeToNamespace;

    public CSharpEmitter(Dictionary<string, ProtoFile> files)
    {
        _files = files;
        _typeToNamespace = BuildTypeNamespaceMap(files);
    }

    private static Dictionary<string, string> BuildTypeNamespaceMap(Dictionary<string, ProtoFile> files)
    {
        var map = new Dictionary<string, string>();

        foreach (var (_, file) in files)
        {
            var ns = file.CSharpNamespace ?? PackageToNamespace(file.Package);

            foreach (var msg in file.Messages)
            {
                RegisterType(map, file.Package, msg.Name, ns);
                RegisterNestedTypes(map, file.Package, msg, ns, msg.Name);
            }

            foreach (var e in file.Enums)
            {
                RegisterType(map, file.Package, e.Name, ns);
            }
        }

        return map;
    }

    private static void RegisterType(Dictionary<string, string> map, string package, string typeName, string ns)
    {
        map[$"{package}.{typeName}"] = ns;
        map[typeName] = ns;
    }

    private static void RegisterNestedTypes(Dictionary<string, string> map, string package, ProtoMessage msg, string ns, string parentPath)
    {
        foreach (var nested in msg.NestedMessages)
        {
            var path = $"{parentPath}.{nested.Name}";
            RegisterType(map, package, path, ns);
            RegisterNestedTypes(map, package, nested, ns, path);
        }

        foreach (var e in msg.NestedEnums)
        {
            RegisterType(map, package, $"{parentPath}.{e.Name}", ns);
        }
    }

    public string Emit(ProtoFile file)
    {
        var sb = new StringBuilder();
        var ns = file.CSharpNamespace ?? PackageToNamespace(file.Package);

        sb.AppendLine("// <auto-generated>");
        sb.AppendLine("//     Generated by ProtoPocoGen. Do not edit.");
        sb.AppendLine("// </auto-generated>");
        sb.AppendLine();
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Text.Json.Serialization;");
        sb.AppendLine();

        // Collect all needed namespaces from imports
        var usedNamespaces = new HashSet<string>();
        CollectUsedNamespaces(file, usedNamespaces, ns);

        foreach (var usedNs in usedNamespaces.OrderBy(x => x))
        {
            if (usedNs != ns)
            {
                sb.AppendLine($"using {usedNs};");
            }
        }

        if (usedNamespaces.Count > 0)
        {
            sb.AppendLine();
        }

        sb.AppendLine($"namespace {ns};");
        sb.AppendLine();

        // Emit enums first
        foreach (var e in file.Enums)
        {
            EmitEnum(sb, e, 0);
            sb.AppendLine();
        }

        // Emit messages
        foreach (var msg in file.Messages)
        {
            EmitMessage(sb, msg, 0, ns);
            sb.AppendLine();
        }

        return sb.ToString();
    }

    private void CollectUsedNamespaces(ProtoFile file, HashSet<string> namespaces, string currentNs)
    {
        foreach (var msg in file.Messages)
        {
            CollectUsedNamespacesFromMessage(msg, namespaces, currentNs);
        }
    }

    private void CollectUsedNamespacesFromMessage(ProtoMessage msg, HashSet<string> namespaces, string currentNs)
    {
        foreach (var field in msg.Fields)
        {
            AddNamespaceForType(field.Type, namespaces, currentNs);
        }

        foreach (var oneof in msg.Oneofs)
        {
            foreach (var field in oneof.Fields)
            {
                AddNamespaceForType(field.Type, namespaces, currentNs);
            }
        }

        foreach (var nested in msg.NestedMessages)
        {
            CollectUsedNamespacesFromMessage(nested, namespaces, currentNs);
        }
    }

    private void AddNamespaceForType(string protoType, HashSet<string> namespaces, string currentNs)
    {
        if (IsPrimitiveType(protoType) || protoType == "google.protobuf.Timestamp")
            return;

        if (_typeToNamespace.TryGetValue(protoType, out var ns) && ns != currentNs)
        {
            namespaces.Add(ns);
        }
    }

    private void EmitMessage(StringBuilder sb, ProtoMessage msg, int indent, string currentNs)
    {
        var ind = new string(' ', indent * 4);

        sb.AppendLine($"{ind}public class {msg.Name}");
        sb.AppendLine($"{ind}{{");

        // Emit nested types first (as Types class if any exist)
        if (msg.NestedMessages.Count > 0 || msg.NestedEnums.Count > 0)
        {
            sb.AppendLine($"{ind}    public static class Types");
            sb.AppendLine($"{ind}    {{");

            foreach (var nested in msg.NestedEnums)
            {
                EmitEnum(sb, nested, indent + 2);
                sb.AppendLine();
            }

            foreach (var nested in msg.NestedMessages)
            {
                EmitMessage(sb, nested, indent + 2, currentNs);
                sb.AppendLine();
            }

            sb.AppendLine($"{ind}    }}");
            sb.AppendLine();
        }

        // Emit regular fields
        foreach (var field in msg.Fields)
        {
            if (field.IsDeprecated)
            {
                sb.AppendLine($"{ind}    [Obsolete]");
            }

            var jsonName = ToCamelCase(field.Name);
            var csType = GetCSharpType(field.Type, field.IsOptional, field.IsRepeated, msg, currentNs);
            var csName = ToPascalCase(field.Name);
            var defaultValue = GetDefaultValue(field.Type, field.IsOptional, field.IsRepeated);

            sb.AppendLine($"{ind}    [JsonPropertyName(\"{jsonName}\")]");

            // Add JsonIgnore for nullable types (optional, timestamp, or message types)
            if (field.IsOptional || IsNullableType(field.Type) ||
                (!IsPrimitiveType(field.Type) && !IsEnumType(field.Type)))
            {
                sb.AppendLine($"{ind}    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]");
            }

            sb.AppendLine($"{ind}    public {csType} {csName} {{ get; set; }}{defaultValue}");
            sb.AppendLine();
        }

        // Emit oneof fields
        foreach (var oneof in msg.Oneofs)
        {
            sb.AppendLine($"{ind}    // oneof: {oneof.Name}");

            foreach (var field in oneof.Fields)
            {
                var jsonName = ToCamelCase(field.Name);
                var csType = GetCSharpType(field.Type, isOptional: true, isRepeated: false, msg, currentNs);
                var csName = ToPascalCase(field.Name);

                sb.AppendLine($"{ind}    [JsonPropertyName(\"{jsonName}\")]");
                sb.AppendLine($"{ind}    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]");
                sb.AppendLine($"{ind}    public {csType} {csName} {{ get; set; }}");
                sb.AppendLine();
            }
        }

        sb.AppendLine($"{ind}}}");
    }

    private void EmitEnum(StringBuilder sb, ProtoEnum e, int indent)
    {
        var ind = new string(' ', indent * 4);

        sb.AppendLine($"{ind}[JsonConverter(typeof(JsonStringEnumConverter))]");
        sb.AppendLine($"{ind}public enum {e.Name}");
        sb.AppendLine($"{ind}{{");

        foreach (var value in e.Values)
        {
            var csName = EnumValueToCSharpName(value.Name, e.Name);
            sb.AppendLine($"{ind}    [JsonStringEnumMemberName(\"{value.Name}\")]");
            sb.AppendLine($"{ind}    {csName} = {value.Number},");
            sb.AppendLine();
        }

        sb.AppendLine($"{ind}}}");
    }

    private string GetCSharpType(string protoType, bool isOptional, bool isRepeated, ProtoMessage? context, string currentNs)
    {
        var baseType = protoType switch
        {
            "string" => "string",
            "int32" => "int",
            "int64" => "long",
            "uint32" => "uint",
            "uint64" => "ulong",
            "float" => "float",
            "double" => "double",
            "bool" => "bool",
            "bytes" => "byte[]",
            "google.protobuf.Timestamp" => "DateTime",
            _ => ResolveTypeName(protoType, context, currentNs)
        };

        if (isRepeated)
        {
            return $"List<{baseType}>?";
        }

        if (isOptional || IsNullableType(protoType))
        {
            return $"{baseType}?";
        }

        // Non-optional reference types (message types) should also be nullable
        // since protobuf allows them to be unset
        if (!IsPrimitiveType(protoType) && !IsEnumType(protoType))
        {
            return $"{baseType}?";
        }

        return baseType;
    }

    private string ResolveTypeName(string protoType, ProtoMessage? context, string currentNs)
    {
        // Check if it's a nested type reference like "ParentMessage.NestedType"
        if (protoType.Contains('.'))
        {
            var parts = protoType.Split('.');

            // Check if it's a fully qualified type from another package (e.g., headless.v1.Session)
            if (_typeToNamespace.TryGetValue(protoType, out var typeNs))
            {
                // If the type is from the same namespace, it's a nested type reference
                // (e.g., AllowedAccessEntry.AccessType in the same file)
                if (typeNs == currentNs)
                {
                    // It's a nested type reference within the same file
                    // Convert to ParentMessage.Types.NestedType format
                    var result = ToPascalCase(parts[0]);
                    for (int i = 1; i < parts.Length; i++)
                    {
                        result += $".Types.{ToPascalCase(parts[i])}";
                    }
                    return result;
                }
                else
                {
                    // It's from another package - check if there's a name conflict
                    var simpleName = ToPascalCase(parts.Last());

                    // Check if the current namespace also has a type with this name
                    var hasConflict = _typeToNamespace.Any(kvp =>
                        kvp.Value == currentNs &&
                        kvp.Key.Split('.').Last().Equals(parts.Last(), StringComparison.OrdinalIgnoreCase));

                    if (hasConflict)
                    {
                        // Use fully qualified name to avoid ambiguity
                        return $"{typeNs}.{simpleName}";
                    }

                    return simpleName;
                }
            }

            // Unknown type with dots - assume it's a nested type reference
            if (parts.Length == 2)
            {
                return $"{ToPascalCase(parts[0])}.Types.{ToPascalCase(parts[1])}";
            }

            var resultPath = ToPascalCase(parts[0]);
            for (int i = 1; i < parts.Length; i++)
            {
                resultPath += $".Types.{ToPascalCase(parts[i])}";
            }
            return resultPath;
        }

        // Check if it's a sibling nested type
        if (context != null)
        {
            var nestedEnum = context.NestedEnums.FirstOrDefault(e => e.Name == protoType);
            if (nestedEnum != null)
            {
                return $"Types.{protoType}";
            }

            var nestedMsg = context.NestedMessages.FirstOrDefault(m => m.Name == protoType);
            if (nestedMsg != null)
            {
                return $"Types.{protoType}";
            }
        }

        return ToPascalCase(protoType);
    }

    private static bool IsPrimitiveType(string protoType)
    {
        return protoType is "string" or "int32" or "int64" or "uint32" or "uint64"
            or "float" or "double" or "bool" or "bytes";
    }

    private bool IsEnumType(string protoType)
    {
        // Check if the type is a known enum
        foreach (var (_, file) in _files)
        {
            if (file.Enums.Any(e => e.Name == protoType || $"{file.Package}.{e.Name}" == protoType))
                return true;

            foreach (var msg in file.Messages)
            {
                if (IsNestedEnumType(msg, protoType, file.Package))
                    return true;
            }
        }
        return false;
    }

    private static bool IsNestedEnumType(ProtoMessage msg, string protoType, string package)
    {
        foreach (var e in msg.NestedEnums)
        {
            if (e.Name == protoType || $"{msg.Name}.{e.Name}" == protoType)
                return true;
        }

        foreach (var nested in msg.NestedMessages)
        {
            if (IsNestedEnumType(nested, protoType, package))
                return true;
        }

        return false;
    }

    private static bool IsValueType(string protoType)
    {
        return protoType is "int32" or "int64" or "uint32" or "uint64"
            or "float" or "double" or "bool" or "google.protobuf.Timestamp";
    }

    private static bool IsNullableType(string protoType)
    {
        return protoType == "google.protobuf.Timestamp";
    }

    private static string GetDefaultValue(string protoType, bool isOptional, bool isRepeated)
    {
        if (isRepeated)
        {
            return " = new();";
        }

        if (isOptional || IsNullableType(protoType))
        {
            return "";
        }

        return protoType switch
        {
            "string" => " = \"\";",
            "bytes" => " = Array.Empty<byte>();",
            _ => ""
        };
    }

    private static string PackageToNamespace(string package)
    {
        // Convert hdlctrl.v1 -> Hdlctrl.V1
        var parts = package.Split('.');
        return string.Join(".", parts.Select(p => ToPascalCase(p)));
    }

    private static string ToPascalCase(string name)
    {
        if (string.IsNullOrEmpty(name)) return name;

        // If already PascalCase (starts with uppercase and contains no underscores), return as-is
        if (char.IsUpper(name[0]) && !name.Contains('_'))
        {
            return name;
        }

        // Handle snake_case
        var parts = name.Split('_');
        return string.Join("", parts.Select(p =>
            p.Length > 0 ? char.ToUpper(p[0]) + p.Substring(1).ToLower() : ""));
    }

    private static string ToCamelCase(string name)
    {
        var pascal = ToPascalCase(name);
        if (string.IsNullOrEmpty(pascal)) return pascal;
        return char.ToLower(pascal[0]) + pascal.Substring(1);
    }

    private static string EnumValueToCSharpName(string protoName, string enumName)
    {
        // Convert HEADLESS_HOST_STATUS_RUNNING -> Running
        // First, try to remove enum name prefix
        var prefix = ToScreamingSnakeCase(enumName) + "_";
        var name = protoName;

        if (name.StartsWith(prefix))
        {
            name = name.Substring(prefix.Length);
        }

        // Convert remaining SCREAMING_SNAKE_CASE to PascalCase
        return ToPascalCase(name.ToLower());
    }

    private static string ToScreamingSnakeCase(string name)
    {
        // Convert HeadlessHostStatus -> HEADLESS_HOST_STATUS
        var result = new StringBuilder();

        for (int i = 0; i < name.Length; i++)
        {
            if (i > 0 && char.IsUpper(name[i]))
            {
                result.Append('_');
            }
            result.Append(char.ToUpper(name[i]));
        }

        return result.ToString();
    }

    // ========== Client Generation ==========

    public string EmitClient(ProtoFile file)
    {
        if (file.Services.Count == 0)
            return string.Empty;

        var sb = new StringBuilder();
        var ns = file.CSharpNamespace ?? PackageToNamespace(file.Package);

        sb.AppendLine("// <auto-generated>");
        sb.AppendLine("//     Generated by ProtoPocoGen. Do not edit.");
        sb.AppendLine("// </auto-generated>");
        sb.AppendLine();
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Net.Http;");
        sb.AppendLine("using System.Text;");
        sb.AppendLine("using System.Text.Json;");
        sb.AppendLine("using System.Text.Json.Serialization;");
        sb.AppendLine("using System.Threading;");
        sb.AppendLine("using System.Threading.Tasks;");
        sb.AppendLine();

        // Collect namespaces needed for request/response types
        var usedNamespaces = new HashSet<string>();
        CollectUsedNamespacesFromServices(file, usedNamespaces, ns);

        foreach (var usedNs in usedNamespaces.OrderBy(x => x))
        {
            if (usedNs != ns)
            {
                sb.AppendLine($"using {usedNs};");
            }
        }

        if (usedNamespaces.Count > 0)
            sb.AppendLine();

        sb.AppendLine($"namespace {ns};");
        sb.AppendLine();

        foreach (var service in file.Services)
        {
            EmitServiceClient(sb, service, file.Package, ns);
            sb.AppendLine();
        }

        return sb.ToString();
    }

    private void CollectUsedNamespacesFromServices(ProtoFile file, HashSet<string> namespaces, string currentNs)
    {
        foreach (var service in file.Services)
        {
            foreach (var rpc in service.Rpcs)
            {
                AddNamespaceForType(rpc.RequestType, namespaces, currentNs);
                AddNamespaceForType(rpc.ResponseType, namespaces, currentNs);
            }
        }
    }

    private void EmitServiceClient(StringBuilder sb, ProtoService service, string package, string currentNs)
    {
        var clientName = $"{service.Name}Client";
        var fullServiceName = $"{package}.{service.Name}";

        sb.AppendLine($"/// <summary>");
        sb.AppendLine($"/// Auto-generated client for {service.Name}");
        sb.AppendLine($"/// </summary>");
        sb.AppendLine($"public class {clientName}");
        sb.AppendLine("{");
        sb.AppendLine($"    public const string ServiceName = \"{fullServiceName}\";");
        sb.AppendLine();
        sb.AppendLine("    protected readonly HttpClient _httpClient;");
        sb.AppendLine("    protected readonly string _baseAddress;");
        sb.AppendLine("    protected readonly JsonSerializerOptions _jsonOptions;");
        sb.AppendLine();

        // Constructor
        sb.AppendLine($"    public {clientName}(HttpClient httpClient, string baseAddress, JsonSerializerOptions? jsonOptions = null)");
        sb.AppendLine("    {");
        sb.AppendLine("        _httpClient = httpClient;");
        sb.AppendLine("        _baseAddress = baseAddress.TrimEnd('/');");
        sb.AppendLine("        _jsonOptions = jsonOptions ?? CreateDefaultJsonOptions();");
        sb.AppendLine("    }");
        sb.AppendLine();

        // Default JSON options
        sb.AppendLine("    private static JsonSerializerOptions CreateDefaultJsonOptions() => new()");
        sb.AppendLine("    {");
        sb.AppendLine("        PropertyNamingPolicy = JsonNamingPolicy.CamelCase,");
        sb.AppendLine("        DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull");
        sb.AppendLine("    };");
        sb.AppendLine();

        // Customization hooks
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Called before sending a request. Override to add authentication headers, etc.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    protected virtual void ConfigureRequest(HttpRequestMessage request) { }");
        sb.AppendLine();

        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Called when a request fails. Return true to retry the request.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    /// <param name=\"response\">The failed response</param>");
        sb.AppendLine("    /// <param name=\"retryCount\">Current retry count (starts at 0)</param>");
        sb.AppendLine("    /// <param name=\"cancellationToken\">Cancellation token</param>");
        sb.AppendLine("    /// <returns>True to retry, false to throw</returns>");
        sb.AppendLine("    protected virtual Task<bool> OnRequestFailedAsync(");
        sb.AppendLine("        HttpResponseMessage response,");
        sb.AppendLine("        int retryCount,");
        sb.AppendLine("        CancellationToken cancellationToken)");
        sb.AppendLine("    {");
        sb.AppendLine("        return Task.FromResult(false);");
        sb.AppendLine("    }");
        sb.AppendLine();

        // RequestAsync method
        sb.AppendLine("    protected virtual async Task<TResponse> RequestAsync<TRequest, TResponse>(");
        sb.AppendLine("        string rpcName,");
        sb.AppendLine("        TRequest request,");
        sb.AppendLine("        CancellationToken cancellationToken = default)");
        sb.AppendLine("    {");
        sb.AppendLine("        var retryCount = 0;");
        sb.AppendLine("        while (true)");
        sb.AppendLine("        {");
        sb.AppendLine("            var json = JsonSerializer.Serialize(request, _jsonOptions);");
        sb.AppendLine("            var httpRequest = new HttpRequestMessage(HttpMethod.Post,");
        sb.AppendLine("                $\"{_baseAddress}/{ServiceName}/{rpcName}\");");
        sb.AppendLine("            httpRequest.Content = new StringContent(json, Encoding.UTF8, \"application/json\");");
        sb.AppendLine();
        sb.AppendLine("            ConfigureRequest(httpRequest);");
        sb.AppendLine();
        sb.AppendLine("            var response = await _httpClient.SendAsync(httpRequest, cancellationToken);");
        sb.AppendLine();
        sb.AppendLine("            if (!response.IsSuccessStatusCode)");
        sb.AppendLine("            {");
        sb.AppendLine("                if (await OnRequestFailedAsync(response, retryCount, cancellationToken))");
        sb.AppendLine("                {");
        sb.AppendLine("                    retryCount++;");
        sb.AppendLine("                    continue;");
        sb.AppendLine("                }");
        sb.AppendLine("            }");
        sb.AppendLine();
        sb.AppendLine("            response.EnsureSuccessStatusCode();");
        sb.AppendLine();
        sb.AppendLine("            var responseJson = await response.Content.ReadAsStringAsync(cancellationToken);");
        sb.AppendLine("            return JsonSerializer.Deserialize<TResponse>(responseJson, _jsonOptions)!;");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine();

        // RPC methods
        foreach (var rpc in service.Rpcs)
        {
            EmitRpcMethod(sb, rpc, currentNs);
        }

        sb.AppendLine("}");
    }

    private void EmitRpcMethod(StringBuilder sb, ProtoRpc rpc, string currentNs)
    {
        var requestType = ResolveServiceTypeName(rpc.RequestType, currentNs);
        var responseType = ResolveServiceTypeName(rpc.ResponseType, currentNs);
        var methodName = $"{rpc.Name}Async";

        sb.AppendLine($"    public virtual Task<{responseType}> {methodName}(");
        sb.AppendLine($"        {requestType} request,");
        sb.AppendLine($"        CancellationToken cancellationToken = default)");
        sb.AppendLine("    {");
        sb.AppendLine($"        return RequestAsync<{requestType}, {responseType}>(");
        sb.AppendLine($"            \"{rpc.Name}\", request, cancellationToken);");
        sb.AppendLine("    }");
        sb.AppendLine();
    }

    private string ResolveServiceTypeName(string protoType, string currentNs)
    {
        // For simple types within same package
        if (!protoType.Contains('.'))
        {
            return ToPascalCase(protoType);
        }

        // For cross-package types like headless.v1.FetchWorldInfoResponse
        if (_typeToNamespace.TryGetValue(protoType, out var typeNs))
        {
            var parts = protoType.Split('.');
            var simpleName = ToPascalCase(parts.Last());

            if (typeNs == currentNs)
            {
                return simpleName;
            }

            // Check for name conflicts
            var hasConflict = _typeToNamespace.Any(kvp =>
                kvp.Value == currentNs &&
                kvp.Key.Split('.').Last().Equals(parts.Last(), StringComparison.OrdinalIgnoreCase));

            if (hasConflict)
            {
                return $"{typeNs}.{simpleName}";
            }

            return simpleName;
        }

        // Unknown type - use as-is with PascalCase conversion
        var typeParts = protoType.Split('.');
        return ToPascalCase(typeParts.Last());
    }
}
